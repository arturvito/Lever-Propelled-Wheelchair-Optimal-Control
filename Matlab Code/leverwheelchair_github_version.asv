clear,clc,close all

condition % load variables

% Specify number of nodes in each one of both phase
nn1 = 51; % number of nodes in phase 1
nn2 = 51; % number of nodes in phase 2

% Phase 2: propulsion phase

toms t1 tf1     
phase1 = tomPhase('phase1', t1, 0, tf1, nn1);

% Phase 2: recovery phase

toms t2 tf2
phase2 = tomPhase('phase2', t2, tf1, tf2-tf1, nn2); 

% Equations of motion
setPhase(phase1);
tomStates gama1 gamad1 a_pos1 a_neg1
tomControls u_pos1 u_neg1
q1 = [gama1]; % Vector of generalized coordinates
qd1 = [gamad1]; % Vector of generalized velocities

setPhase(phase2);
tomStates gama2 gamad2  x02 x02d a_pos2 a_neg2
tomControls u_pos2 u_neg2
q2 = [gama2;x02]; 
qd2 = [gamad2;x02d]; 

setPhase(phase1)
[M1, rhs1] = propulsion([q1; qd1],[tau_pos1; tau_neg1],lax,lay,L3,l3,p,ni,Jl,ml,Froll);
ceq1 = collocate({dot(q1) == qd1; M1*dot(qd1) == rhs1; dot(a_pos1)==(u_pos1-a_pos1)*(u_pos1/t_act+(1-u_pos1)/t_deact); dot(a_neg1)==(u_neg1-a_neg1)*(u_neg1/t_act+(1-u_neg1)/t_deact)});

setPhase(phase2)
[M2, rhs2] = recovery([q2; qd2],[tau_pos2; tau_neg2],lax,lay,L3,l3,p,ni,Jl,ml,Froll);
ceq2 = collocate({dot(q2) == qd2; M2*dot(qd2) == rhs2; dot(a_pos2)==(u_pos2-a_pos2)*(u_pos2/t_act+(1-u_pos2)/t_deact); dot(a_neg2)==(u_neg2-a_neg2)*(u_neg2/t_act+(1-u_neg2)/t_deact)});

% duracao maxima da fase 1
DT1max = 1.5; % [s]

% duracao maxima da fase 2
DT2max = 1.5; % [s]

% Phase 1: propulsion phase

gama_min = gamamin(lax,lay,L3);
gama_max = gamamax(gama_min,lax,lay,L3);

setPhase(phase1) 
cbox1 = { 0.02                  <= tf1                  <= DT1max
          (gama_min)            <= icollocate(gama1)    <= (gama_max) 
          -max_lever_w*pi/180   <= icollocate(gamad1)   <= max_lever_w*pi/180
          0                     <= icollocate(a_pos1)   <= 1
          0                     <= icollocate(a_neg1)   <= 1
         };

setPhase(phase2) 
cbox2 = {     tf1              <= tf2                  <= DT1max+DT2max
                0              <= icollocate(x02)      <= speed*(DT1max+DT2max)
         (gama_min)            <= icollocate(gama2)    <= (gama_max)
                0              <= icollocate(x02d)     <= 10*speed
        -max_lever_w*pi/180    <= icollocate(gamad2)   <= max_lever_w*pi/180 
          0                    <= icollocate(a_pos2)   <= 1
          0                    <= icollocate(a_neg2)   <= 1

         };
%           load initial guess
ini = ['musc_config_' num2str(cg) '_p_' num2str(p) '_v_' num2str(speed) '_ni_' num2str(ni_dg) '.mat'];
pwd_ini = ['inicial/' ini];

load(pwd_ini)
setPhase(phase1)
x10 = {tf1 == opt.tf1
    icollocate({
    gama1 == opt.gama1(1)
    gamad1 == opt.gamad1(1)
    a_pos1 == opt.a_pos1(1)
    a_neg1 == opt.a_neg1(1)
    })}; 
setPhase(phase2)
x20 = {tf2 == opt.tf2
    icollocate({
    gama2 == opt.gama2(1)
    gamad2 == opt.gamad2(1)
    x02 == opt.x02(1)
    x02d == opt.x02d(1)
    a_pos2 == opt.a_pos2(1)
    a_neg2 == opt.a_neg2(1)      
    })};  
% Initial guess for controls
%             
setPhase(phase1)
x10 = {x10
    collocate(u_pos1 == opt.u_pos1(1))
    collocate(u_neg1 == opt.u_neg1(1))};
setPhase(phase2)
x20 = {x20
    collocate(u_pos2 == opt.u_pos2(1))
    collocate(u_neg2 == opt.u_neg2(1))};

% clear initial guess                     
clear opt

% Contraints
% Lower and upper bounds on controls

setPhase(phase1)
cbox1 = {cbox1
    0 <= collocate(u_pos1) 
         collocate(u_pos1) <= 1
    0 <= collocate(u_neg1)
         collocate(u_neg1) <= 1  }; 

setPhase(phase2)
cbox2 = {cbox2
    0 <= collocate(u_pos2) 
         collocate(u_pos2) <= 1
    0 <= collocate(u_neg2) 
         collocate(u_neg2) <= 1}; 

% Inequality constraints

[alfa1,betae1,beta1]=ang(gama1,lax,lay,L3); 
[alfa2,betae2,beta2]=ang(gama2,lax,lay,L3);

setPhase(phase1)
cineq1 = { (betae_min) <= icollocate(betae1) <= betae_max                     
                          icollocate(gamad1) <= 0
         };   

setPhase(phase2)
cineq2 = {(betae_min) <= icollocate(betae2)              <= betae_max  
                         icollocate(-gamad2*p*R2 - x02d) <= 0 
          };    

% Boundary constraints on initial and final states                 
setPhase(phase1)
cbnd1 = {};

setPhase(phase2)
cbnd2 = {initial({x02 == abs((initial(phase1,gama1)-final(phase1,gama1))*p*R2)})
         initial({x02d == abs(final(phase1,gamad1)*p*R2)})
    				 final({x02 == speed*tf2})
         };

link = {final(phase1,gama1) == initial(phase2,gama2)
        final(phase1,gamad1) == initial(phase2,gamad2)
        final(phase2,x02) == speed*tf2 
        final(phase2,gama2) == initial(phase1,gama1)
        final(phase2,x02d) == abs(initial(phase1,gamad1*p*R2)) 
        final(phase2,gamad2) == initial(phase1,gamad1) 
        final(phase2,a_pos2) == initial(phase1,a_pos1)
        final(phase2,a_neg2) == initial(phase1,a_neg1)
        final(phase1,a_pos1) == initial(phase2,a_pos2)
        final(phase1,a_neg1) == initial(phase2,a_neg2)
        }; 

%objective function

objective = ((integrate(phase1, u_pos1^2) + integrate(phase1, u_neg1^2) + integrate(phase2, u_pos2^2) + integrate(phase2, u_neg2^2))/(tf2*speed));

%Solução direta

options = struct;
options.name = 'leverwheelchair';
options.PriLevOpt = 1;
options.Prob.SOL.optPar(30) =  500000;
options.Prob.SOL.optPar(35) =  500000;
options.Prob.SOL.optPar(36) =  500000;
constr = {cbox1, ceq1, cineq1, cbox2, ceq2, cineq2, cbnd1, cbnd2, link};
[solution, prop] = ezsolve(objective, constr, {x10, x20}, options);

% phase1
opt.tf1 = subs(tf1,solution);
opt.t1  = subs(icollocate(phase1,t1),solution);
opt.gama1 = subs(icollocate(phase1,gama1),solution);
opt.gamad1 = subs(icollocate(phase1,gamad1),solution);
opt.a_pos1 = subs(icollocate(phase1,a_pos1),solution);  
opt.a_neg1 = subs(icollocate(phase1,a_neg1),solution);
opt.u_pos1 = subs(icollocate(phase1,u_pos1),solution);  
opt.u_neg1 = subs(icollocate(phase1,u_neg1),solution);             
opt.nn1 = nn1;

opt.x01 = -(opt.gama1-opt.gama1(1))*p*R2;

opt.gamaw1 = opt.gama1*p;
opt.gamawd1 = opt.gamad1*p;

% phase2
opt.tf2 = subs(tf2,solution);
opt.t2  = subs(icollocate(phase2,t2),solution);
opt.gama2 = subs(icollocate(phase2,gama2),solution);
opt.x02 = subs(icollocate(phase2,x02),solution);
opt.gamad2 = subs(icollocate(phase2,gamad2),solution);
opt.x02d = subs(icollocate(phase2,x02d),solution);
opt.a_pos2 = subs(icollocate(phase2,a_pos2),solution);  
opt.a_neg2 = subs(icollocate(phase2,a_neg2),solution);  
opt.u_pos2 = subs(icollocate(phase2,u_pos2),solution);  
opt.u_neg2 = subs(icollocate(phase2,u_neg2),solution);             
opt.objective = subs(objective,solution);
opt.nn2 = nn2;

opt.gamawd2 = -opt.x02d./R2; 

opt.speed = speed;

opt.t = [opt.t1; opt.t2];
opt.a_pos = [opt.a_pos1; opt.a_pos2];
opt.a_neg = [opt.a_neg1; opt.a_neg2];
opt.u_pos = [opt.u_pos1; opt.u_pos2];
opt.u_neg = [opt.u_neg1; opt.u_neg2];            
opt.gama =[opt.gama1;opt.gama2];
opt.gamad = [opt.gamad1;opt.gamad2];
opt.x0 = [opt.x01;opt.x02];
opt.gamawd = [opt.gamawd1;opt.gamawd2];

[opt.alfa,opt.betae,opt.beta]=ang(opt.gama,lax,lay,L3);


